import UIKit


// Optional Types

/*
1. ИТАК: в Swift ВСЕ свойства д.б. инициализированы - ??? -  без этого проект НЕ соберется
2. см. пример: создай класс с двумя var типа String. НО в таком виде класс НЕ оставим - ???
3. эти свойства НЕ инициализированы -> не имеют значения => НЕ можем создать экземпляр класса
4. при создании экземпляра класса в ПАМЯТИ д.б. сохранены значения для этих свойств -> и передать значение не можем, + по умолчанию значения НЕ заданы - ошибка компиляции, проект не собирается */

/* class Person {
    var name: String
    var surname: String
} // error - class 'Person' has no initializers!


5. удалим ТИП данных и присвоим значение ПО УМОЛЧАНИЮ
 6. ТИП даннныъ определяется из значений по умолчанию
 7. когда создадим экземпляр класса -> в памяти наши свойства будут сохранены с этими значениями - пустой строки

 class Person {
    var name = ""
    var surname = ""
}

8. Но если базовым типам можно присвоить значение по умолчанию("", 0, 0.0), то пользовательским типам - НЕ всегда м.б.
 9. давайте определим структуру 'dog' - нам нужна ошибка инициализации свойств - ??? - выявить ПРОБЛЕМУ!
 10. NB: в отличие от классов - в структурах AUTO встроены инициализаторы
 11. заменим class-> struct - и все ошибки исчезнут!
 
class Person {
    var name = ""
    var surname = ""
    var dog: Dog // как быть? такое свойство м.б. определено как ОПЦИОНАЛЬНОЕ - var dog: Dog ?
}
struct Dog {
    let name: String
    let age: Int
} // не инициализированы свойства в струткурах, но ошибки компиляции нет! - ??? - AUTO встроенный инициализатор

     11. когда захотим создать экземпляр структуры - XCode обяжет передать значения параметра инициализатора этой структуры
     12. есть человек + он может иметь собаку
     объявим var dog: Dog - ошибка! - свойство НЕ инициализировано
     13. как присвоить значение? по умолчанию - не приcвою - какие значения можно передать? -> ""?
     14. см.: создадим экземпляр класса 'Person'
    
let tim = Person()
tim.name = "Tim" // присвоим имя  - ТИМ
tim.dog // у Тима по жизни НЕТ собаки, но мы ее добавили, хотя собаки НЕТ
    
     15. de facto - cм. код - она ЕСТЬ у Тима собака без имени + возраст = 0.
     16. что сделали? в память добавили экземпляр класса дог и выделили ячейку ПАМЯТИ и положили в нее этого пса со значениями по умолчанию и он там лежит.Хотя его быть НЕ должно!
     17. пустые скобки НЕ РАБОТАЮТ - создали экземпляр собаки для человека, у которого собаки НЕТ.
     18. как быть?
     19. такое свойство м.б. определено как ОПЦИОНАЛЬНОЕ.
     20. если не инициализировать -> по умолчанию опциональное свойство содержит nil - т.е. НЕТ значения, НЕТ объекта
     21. это как заглушка для компилятора
     
     ОСОБЕННОСТИ ОПЦИОНАЛЬНЫХ ТИПОВ:
     1. НЕ совместимы с обычными свойствами => НЕ можем НАПРЯМУЮ передать значение опционал. свойств в НЕопциональные.
     2. как так? напр.: данные о user и его питомце получаем извне, из СЕТИ, от сервера - см. профиль юзера - если сервер НИЧЕГО НЕ вернет - нет Сети, в базе НЕТ объекта => НЕЧЕГО отображать.
     3. свойство с инфой: имя пса + возраст  определяются как OPTIONAL -> могут иметь значения / могут НЕ иметь - ? - если отсутствует подключение к интернету
     4. объявляем свойство 'dogName' типа String и присваиваем ему имя - 'Rex'
     5. 'dogName' - это обычное свойство с типом String - ОБЯЗАНЫ ИНИЦИАЛИЗИРОВАТЬ текстовым значением и НЕ можем присвоить nil
 
let dogName = "Rex"

// чтобы свойство стало ОПЦИОНАЛЬНЫМ -
let dogName: String? = "Rex"
let dogAge: Int? = 1
let

 1. нужно ЯВНО указать ТИП ДАННЫХ - может хранить строку / пустую строку / nil
 2. как эти опциональные данные передать?
 
let dogName: String? = "Rex"
let dogAge: Int? = 1
let dog = Dog(name: dogName, age: dogAge)

передадим эти данные в свойства пса -> error! - ??? - nil не м.б. передан в обычные свойства - ошибка компиляции - НЕ дружат обычные и опциональные свойства!
     
см.: Что предлагает XCode?

// вар. 1 ПРИНУДИТЕЛЬНОЕ ИЗВЛЕЧЕНИЕ ОПЦИОНАЛА

'FORCE-UNWRAP' - пер. с англ. "принудительное извлечение"
     NB: Августин Блаженный - 'Coge intrare!' - пер. с лат. "принуди войти"

let dog = Dog(name: dogName!, age: dogAge!)

 1. ошибки пропали, все ок! НО что здесь НЕ так?
 2. dogName! = "мамой клянусь, в этом свойстве есть значение с типом String" - компилятор - ок!

class Person {
    var name = ""
    var surname = ""
    var dog: Dog? // как быть? такое свойство м.б. определено как ОПЦИОНАЛЬНОЕ
}
    
struct Dog {
    let name: String
    let age: Int
}
    
let tim = Person()
tim.name = "Tim"
tim.dog

// let dog = Dog(name: dogName!, age: dogAge!)
let dogName: String? = "Rex"
let dogAge: Int?
 
 1. НО если применить 'forceUnwrap' к свойству, которое содержит 'nil' -
    - константы НЕ м.б. отциональными - ??? - НЕ сможем присвоить значение этому свойству где-то еще - зачем нам let всегда содержит nil
    - только ПЕРЕМЕННЫЕ БЕЗ ЗНАЧЕНИЯ
    => fatal error! ошибка с памятью - "ихтамнет"
 2. ЕЩЕ РАЗ: ничего НЕ хранится, а мы ЗАРЕЗЕРВИРОВАЛИ - а там - ПУСТО! Так делать НЕЛЬЗЯ!

Что предлагает XCode как альтернативу? */

// вар. 2 ИСПОЛЬЗОВАНИЕ ЗНАЧЕНИЙ ПО УМОЛЧАНИЮ

 // let dog = Dog(name: dogName ?? "", age: dogAge ?? 0)

 /* читаем так:
 "давай возьмем значение свойства 'dogName', НО т.к. опциональное, то если будет nil - воспользуйся ПО УМОЛЧАНИЮ значением (default value) пустой строки"

1. ТАКОЙ рабочий код НЕ ПИШУТ! только в учебных целях/примерах/документации от Apple - принудительное извлечение опционалов для джуна - ТАБУ!
 
2. => переделай класс -> в структуру
3. так и должно было быть ИЗНАЧАЛЬНО! */

// ОПЦИОНАЛЬНАЯ ПРИВЯЗКА
 
 struct Person {
     let name: String // обязательное для инициализации свойство
     var surname: String? // НЕ обязат. для иниц-ии свойство - ? юзер м. указать фамилию / не захотел
     var dogs: [Dog] = [] // по умолчанию у человека НЕТ собак
 }
     
 struct Dog { // создали структуру, определяющую пса
     let name: String
     let age: Int
 }

var tim = Person(name: "Tim", surname: "Cook") // создали экземпляр класса - Тим Кук
let dogName: String? = "Rex"
var dogAge: Int? // с сервера пришли данные: имя пса, а возраст - нет


var dog: Dog? = Dog(name: dogName ?? "", age: dogAge ?? 0)
}
/* error! не м. опционал. значение -> в НЕопционал. массив - dog и dog! - РАЗНЫЕ ТИПЫ даных и по умолчанию передать значение НЕ МОЖЕМ - опять ошибка. Help!

 что можем сделать?

спасет концепция опциональной привязки: она позволяет ИЗВЛЕКАТЬ значение из optional type, если оно ИМЕЕТСЯ и ПЕРЕДАВАТЬ его в ОБЫЧНОЕ НЕопционал. значение, которое затем м.б. использовано.
 ИТАК:
1. есть опциональное свойство
2. можем взять пса и -> его Тиму Куку
3. ГЛАВНОЕ: определить - а ИМЕЕТСЯ ли ЗНАЧЕНИЕ?
4. извлечь его и поместить в массив с псами
5. НО еслм значение отсуствует - 'nil' - НЕ ПОМЕЩАТЬ
6. ПРОВЕРКА: если в опционал. свойстве ЕСТЬ данные - то создай КОПИЮ
if let dog {
    tim.dogs.append(dog) // подружим человека с псом: Тим, давай мы тебе подарим пса - + в пустой массив */

tim.dogs // 1 element [(nane: "Rex", age: 0)] - проверка появился пес у Тима Кука?

/*
 ИТАК:
 1. свойство 'dog' опциональное
 2. если в экземпляре 'dog' ЕСТЬ ОБЪЕКТ => извлекаем объект в НОВУЮ константу с ТЕМ же самым ИМЕНЕМ
 3. НО это уже ОБЫЧНАЯ КОНСТАНТА - мы ее создали НОВУЮ let со значением, которое содержится в ОПЦИОНАЛ. ПЕРЕМЕННОЙ
 4. это сработает только ЕСЛИ есть ДАННЫЕ
 5. КАК получилось, что созданы два ОДНОименных свойства - let / var?
 6. 'if let dog' создана в ЛОКАЛЬНОЙ ЗОНЕ ВИДИМОСТИ 'if' (class, struct) независимо от внешней var
 7. RESULT: let в отрыве от var - НО ГЛАВНОЕ - она НЕ ОПЦИОНАЛЬНА т.е. мы передали Тиму Куку ВНУТРЕННЕГО пса - let, а не внешнего пса - var.
 */

