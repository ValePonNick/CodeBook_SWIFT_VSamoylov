import UIKit

// SUMMARY INOUT: конспект + задачи

/*
 Inout - это ключевое слово, которое позволяет изменять значение параметра ВНУТРИ функции, а эти изменения применяются и ВНЕ функции, т.е. функция может МОДИФИЦИРОВАТЬ переданный ей аргумент и изменить его значение, которое будет видно ПОСЛЕ завершения вызова функции.
 ОСОБЕННОСТИ inout:
    - параметры функций по умолчанию КОНСТАНТЫ => их значения НЕ м.б. изменены ВНУТРИ функции.
    - используй 'inout': если хотим ИЗМЕНИТЬ значение параметра ВНУТРИ функции и СОХРАНИТЬ изменения ВНЕ функции, ОБЪЯВИ этот параметр как 'inout'
    - для этого используй ключевое слово  'inout' ПЕРЕД типом параметра
    - это позволит функции ИЗМЕНИТЬ значение переменной, переданной в качестве АРГУМЕНТА.
    - ПЕРЕДАЧА ПО ССЫЛКЕ: используя 'inout' переменная передется в функцию ПО ССЫЛКЕ, а не по ЗНАЧЕНИЮ
    - функция получает адрес переменной в память, а не КОПИЮ ее значения, => изменения, внесенные ВНУТРИ функции, НАПРЯМУЮ влияют на ИСХОДНУЮ переменную в памяти.
     - для этого при ВЫЗОВЕ функции перед ИМЕНЕМ переменной, добавляется амперсанд - '&'
    - ИЗМЕНЕНИЕ ЗНАЧЕНИЯ: внутри функции, когда изменяем значение параметра, объявленного как 'inout', я de facto ИЗМЕНЯЮ значение ПЕРЕМЕННОЙ в ПАМЯТИ, на которую ссылается этот параметр.
    => эти изменения СОХРАНЯЮТСЯ и ПОСЛЕ завершения вызова функции.
    ОДНАКО: технически внутри функции параметр все равно является КОНСТАНТОЙ, если бы он НЕ был объявлен как 'inout'. Использование 'inout' позволяет ОБОЙТИ это ограничение, позволяя функции ИЗМЕНЯТЬ ВНЕШНИЙ / ВХОДНОЙ ПАРАМЕТР
 
Механизм `inout` в памяти
 Основные понятия
     •    Стек и куча: В Swift, типы значений (`Int`, `String`, `struct`) обычно хранятся в стеке, а ссылочные типы (`class`, замыкания) — в куче.
     •    Передача по значению и по ссылке: По умолчанию, функции в Swift получают копию переданных им значений (передача по значению). Однако, когда используется `inout`, функция получает ссылку на исходное значение (передача по ссылке)
 
 Механизм `inout` в памяти
 1. Выделение памяти: Когда вы объявляете переменную, например, `var number = 6`, память для этой переменной выделяется в стеке.
 2. Передача по ссылке: Когда вы передаете эту переменную в функцию с помощью `inout`, например, `func doubleNumber(num: inout Int)`, функция получает адрес памяти, где хранится `number`. Это означает, что функция работает не с копией значения, а с исходным значением в памяти.
 3. Изменение значения: Внутри функции, когда вы изменяете значение `num`, вы фактически изменяете значение в памяти, на которое ссылается `num`. Это изменение сохраняется после завершения вызова функции, потому что функция работала с исходным значением в памяти.
 4. Отсутствие права собственности: Функция не получает права собственности на память, на которую ссылается `inout` параметр. Это означает, что функция может изменять значение, но НЕ может освободить/выделить память для этого значения.
 
 Важные моменты
     •    Передача по ссылке: `inout` позволяет функциям изменять значения, переданные в них, работая с исходными значениями в памяти.
     •    Отсутствие права собственности: Функции не получают права собственности на память, на которую ссылаются `inout` параметры.
     •    Эффективное использование памяти: Использование `inout` может быть более эффективным, чем передача по значению, особенно для больших данных, поскольку НЕ создает копии.
 */
 
// классический пример использования 'inout'
/*
ЗАДАЧА: обмен значений
стакан а = молоко
стакан б = вода
стакан temp = пуст  */

func swapNumbs(x: inout Double, y: inout Double) {
    let temp = x
    x = y
    y = temp
}
var x = 3.14159
var y = 7.77777

print("До обмена: x = \(x), y = \(y)")
swapNumbs(x: &x, y: &y)
print("После обмена: x = \(x), y = \(y)")

/* ЗАДАЧА: напиши функцию, которая добавляет к переданному значению заданное число */

func addValue(num: inout Int, n: Int) {
    num += n
}
var value = 12
let n = 10
print("До добавления: \(value)")
addValue(num: &value, n: n)
print("После добавления: \(value)")

// пример функции ВНУТРИ структуры
var a = 5
var b = 12
struct Playground {
    func swapNumbers(a: inout Int, b: inout Int) {
        let temp = a // перелили молоко в пустой стакан сохранили значение 'a' в константе
        a = b // перелили воду в стакан из-под молока присвоили значение a -> b
        b = temp // перелили из временного стакана молоко в стакан из-под воды
        // присвоили значение  b -> temp
    }
}
let play = Playground()
play.swapNumbers(a: &a, b: &b)
print("После обмена a = \(a), b = \(b)")
print(b)

// УНИВЕРСАЛЬНАЯ функция ОБМЕНА
func swapValues<T>(_ aa: inout T, _ bb: inout T) {
    let temp = aa
    aa = bb
    bb = temp
}
var someInt = 21
var anotherInt = 12
swapValues(&someInt, &anotherInt)
print("Теперь someInt = \(someInt), а anotherInt = \(anotherInt)")
var someString = "Hello"
var anotherString = "world"
swapValues(&someString, &anotherString)
print("Теперь someString = \(someString), а anotherString = \(anotherString)")

// ЗАДАЧА: решение для РАЗНЫХ ТИПОВ - пример с КОРТЕЖАМИ

var firstTuple: (Int, String) = (12, "дюжина")
var secondTuple: (Int, String) = (21, "очко")

func swapTuples(_ w: inout(Int, String), _ q: inout (Int, String)) {
    let temp = w
    w = q
    q = temp
}
swapTuples(&firstTuple, &secondTuple)
print("Теперь первый кортеж равен \(firstTuple), а второй кортеж - \(secondTuple)")

// Замена значений в СТРУКТУРАХ ДАННЫХ - МАССИВАХ и СЛОВАРЯХ
// поменяем значения элементов в МАССИВЕ
var numbers = [1, 2, 3, 4, 5, 6, 7]
func swapElements(at index1: Int, and index2: Int, in array: inout [Int]) {
    let temp = array[index1]
    array[index1] = array[index2]
    array[index2] = temp
}
swapElements(at: 1, and: 5, in: &numbers)
print(numbers)

// поменяем значения элементов в СЛОВАРЕ
var myDict:[String: Any] = ["name": "Bob", "age": 12]
// замена значений по КЛЮЧУ
myDict["name"] = "Jane"
print(myDict)

// использование ВРЕМЕННОЙ ПЕРЕМЕННОЙ
// обмен значений КЛЮЧЕЙ в СЛОВАРЕ
let tmp = myDict["name"]
myDict["name"] = myDict["age"]
myDict["age"] = tmp

print(myDict)

// обмен значений с использованием КОРТЕЖЕЙ
var myDictionary: [String: String] = ["child": "Vincent", "job": "IT"]

// создание КОРТЕЖЕЙ
var anyTuple: (String, String) = (myDictionary["child"] ?? "", myDictionary["job"] ?? "")
var anotherTuple: (String, String) = ("uncnoun", "uncnoun")
// обмен значениями КОРТЕЖЕЙ
func swapTwoTuples(_ f: inout (String, String), _ g: inout (String, String)) {
    let temp = f
    f = g
    g = temp
}
// инициализация ВТОРОГО КОРТЕЖА правильными значениями
anotherTuple = ("Parent", "")
// обмен кортежей
swapTwoTuples(&anyTuple, &anotherTuple)
print("anyTuple after swap: \(anyTuple)")
print("anotherTuple after swap: \(anotherTuple)")

/* COMMENTS: синтаксис КОРТЕЖА
1. тип кортежа  - (String, String)
2. инициализация кортежа: '(myDictionary["child"] ?? "", myDictionary["job"] ?? "")' - это значения, которые БУДУТ присвоены кортежу
3. использование оператора '??'
    - это оператор nil-coalescing, который используется для предоставления значения ПО УМОЛЧАНИЮ, если выражение слева от него = 'nil'
    - myDictionary["child"] ?? "" означает: если значение по ключу "child" существует в словаре, то исползуй это значение, если НЕТ (т.е. это значение = 'nil'), то используй ПУСТУЮ строку ("")
    - если ключа 'child' /'job' НЕТ в СЛОВАРЕ, то соотв. значение в КОРТЕЖЕ будет пустой строкой */
