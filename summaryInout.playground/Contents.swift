import UIKit

// SUMMARY INOUT: конспект + задачи

/*
 Inout - это ключевое слово, которое позволяет изменять значение параметра ВНУТРИ функции, а эти изменения применяются и ВНЕ функции, т.е. функция может МОДИФИЦИРОВАТЬ переданный ей аргумент и изменить его значение, которое будет видно ПОСЛЕ завершения вызова функции.
 ОСОБЕННОСТИ inout:
    - параметры функций по умолчанию КОНСТАНТЫ => их значения НЕ м.б. изменены ВНУТРИ функции.
    - используй 'inout': если хотим ИЗМЕНИТЬ значение параметра ВНУТРИ функции и СОХРАНИТЬ изменения ВНЕ функции, ОБЪЯВИ этот параметр как 'inout'
    - для этого используй ключевое слово  'inout' ПЕРЕД типом параметра
    - это позволит функции ИЗМЕНИТЬ значение переменной, переданной в качестве АРГУМЕНТА.
    - ПЕРЕДАЧА ПО ССЫЛКЕ: используя 'inout' переменная передется в функцию ПО ССЫЛКЕ, а не по ЗНАЧЕНИЮ
    - функция получает адрес переменной в память, а не КОПИЮ ее значения, => изменения, внесенные ВНУТРИ функции, НАПРЯМУЮ влияют на ИСХОДНУЮ переменную в памяти.
     - для этого при ВЫЗОВЕ функции перед ИМЕНЕМ переменной, добавляется амперсанд - '&'
    - ИЗМЕНЕНИЕ ЗНАЧЕНИЯ: внутри функции, когда изменяем значение параметра, объявленного как 'inout', я de facto ИЗМЕНЯЮ значение ПЕРЕМЕННОЙ в ПАМЯТИ, на которую ссылается этот параметр.
    => эти изменения СОХРАНЯЮТСЯ и ПОСЛЕ завершения вызова функции.
    ОДНАКО: технически внутри функции параметр все равно является КОНСТАНТОЙ, если бы он НЕ был объявлен как 'inout'. Использование 'inout' позволяет ОБОЙТИ это ограничение, позволяя функции ИЗМЕНЯТЬ ВНЕШНИЙ / ВХОДНОЙ ПАРАМЕТР
 
Механизм `inout` в памяти
 Основные понятия
     •    Стек и куча: В Swift, типы значений (например, `Int`, `String`, `struct`) обычно хранятся в стеке, а ссылочные типы (например, `class`, замыкания) — в куче.
     •    Передача по значению и по ссылке: По умолчанию, функции в Swift получают копию переданных им значений (передача по значению). Однако, когда используется `inout`, функция получает ссылку на исходное значение (передача по ссылке)
 
 Механизм `inout` в памяти
 1.    Выделение памяти: Когда вы объявляете переменную, например, `var number = 6`, память для этой переменной выделяется в стеке.
 2.    Передача по ссылке: Когда вы передаете эту переменную в функцию с помощью `inout`, например, `func doubleNumber(num: inout Int)`, функция получает адрес памяти, где хранится `number`. Это означает, что функция работает не с копией значения, а с исходным значением в памяти.
 3.    Изменение значения: Внутри функции, когда вы изменяете значение `num`, вы фактически изменяете значение в памяти, на которое ссылается `num`. Это изменение сохраняется после завершения вызова функции, потому что функция работала с исходным значением в памяти.
 4.    Отсутствие права собственности: Функция не получает права собственности на память, на которую ссылается `inout` параметр. Это означает, что функция может изменять значение, но не может освободить или выделить память для этого значения.
 
 Важные моменты
     •    Передача по ссылке: `inout` позволяет функциям изменять значения, переданные в них, работая с исходными значениями в памяти.
     •    Отсутствие права собственности: Функции не получают права собственности на память, на которую ссылаются `inout` параметры.
     •    Эффективное использование памяти: Использование `inout` может быть более эффективным, чем передача по значению, особенно для больших данных, поскольку избегает создания копий.
 */
 
// пример использования 'inout'
/*
ЗАДАЧА: обмен значений
стакан а = молоко
стакан б = вода
стакан temp = пуст  */

func swapNumbs(x: inout Double, y: inout Double) {
    let temp = x
    x = y
    y = temp
}
var x = 3.14159
var y = 7.77777

print("До обмена: x = \(x), y = \(y)")
swapNumbs(x: &x, y: &y)
print("После обмена: x = \(x), y = \(y)")

/* ЗАДАЧА: напиши функцию, которая добавляет к переданному значению заданное число */

func addValue(num: inout Int, n: Int) {
    num += n
}
var value = 12
let n = 10
print("До добавления: \(value)")
addValue(num: &value, n: n)
print("После добавления: \(value)")

var a = 5
var b = 12

struct Playground {
    
    func swapNumbers(firstNum a:  inout Int, secondNum b:  inout Int) {
        var temp = a // перелили молоко в пустой стакан сохранили значение 'a' в константе
        a = b // перелили воду в стакан из-под молока присвоили значение a -> b
        b = temp // перелили из временного стакана молоко в стакан из-под воды
        // присвоили значение  b -> temp
    }
} //  мы пытаемся вызвать ФУНКЦИЮ - error!
let play = Playground()
play.swapNumbers(firstNum: &a, secondNum: &b)

print(a)
print(b)
