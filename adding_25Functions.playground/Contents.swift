import UIKit

// REPEATING FUNCTIONS: "каждый код мечтает стать функцией"

/* ЗАДАЧА: Фибоначчи - напиши функцию, которая принимает целое число 'n' и возвращает 'n'-ое число Фибоначчи. Последовательность Фибоначчи начинается с 0 и 1, и каждое последующее число является СУММОЙ двух предыдущих. Используй метод рекурсии или цикл для вычисления числа. */

// рекурсивный метод
func calculateNumFibonacci(_ n: Int) -> Int {
    if n == 0 {
        return 0
    } else if n == 1 {
        return 1
    } else {
        return calculateNumFibonacci(n - 1) + calculateNumFibonacci(n - 2)
    }
}
let result = calculateNumFibonacci(7)
print(result)


/* COMMENTS:
 1. этот метод прост, но м.б. НЕэффективен для больших значений n из-за большого количества повторяющихся вычислений.
 2. функция вызывает САМУ себя для (n - 1) и (n - 2), суммируя результаты.
 3. это соотетствует определению чисел Фибоначчи, где каждое число = сумме двух предыдущих. */

// Итеративный метод

func fibonacciIterative(_ n: Int) -> Int {
    if n == 0 { return 0 }
    if n == 1 { return 1 }
    
    var a = 0
    var b = 1
    for _ in 2...n {
        let tmp = a + b
        a = b
        b = tmp
    }
    return b
}
fibonacciIterative(6)
/* COMMENTS:
 1. испльзуй ЦИКЛ для последовательного вычисления чисел Фибоначчи
 2. этот метод требует МЕНЬШЕ ресурсов и работает БЫСТРЕЕ для больших значений n */

// МЕМОИЗАЦИЯ - это простота рекурсии + эффективность за счет ХРАНЕНИЯ результатов
var memo: [Int: Int] = [:] // создай пустой словарь

@MainActor func fibMemoized(_ n: Int) -> Int {
    if let result = memo[n] { // элемент в словаре чисел
        return result
    }
    if n == 0 {
        return 0
    } else if n == 1 {
        return 1
    } else {
        let result = fibMemoized(n - 1) + fibMemoized(n - 2)
        memo[n] = result
        return result // верни элемент из словаря чисел
    }
}
fibMemoized(7)
print(fibMemoized(8))
/* COMMENTS: три метода через их производительность и использование ПАМЯТИ
 1. РЕКУРСИВНЫЙ метод, вычисляя n-е число Фибоначчи, вызывает САМ СЕБЯ для вычисления двух предыдущих чисел
    - временная сложность 0(2n) т.е. КАЖДЫЙ вызов функции приводит в двум НОВЫМ вызовам, что создает ЭКСПОНЕНЦИОНАЛЬНОЕ количество операций
     - использование ПАМЯТИ: высокое т.к. КАЖДЫЙ вызов функции добавляется в СТЕК вызовов.При больших n м.б. ПЕРЕПОЛНЕНИЕ стека
    => метод подходит для НЕбольших значений n
 
 2. ИТЕРАТИВНЫЙ метод:
    - временная сложность 0(n) - каждый шаг цикла выполняется ОДИН раз
    - испльзование памяти: низкое т.к. используется ФИКСированное количество переменных (НЕЗАВИСИМО от n), что делает его более эыыективным, нежели рекурсия
    => max эффективен по времени + памяти
 
 3. метод МЕМОИЗАЦИИ:
    - сохраняет УЖЕ вычисленные значения для предотвращения ПОВТОРНЫХ вычислений
    - временная сложность 0(n) - каждое число вычисляется только ОДИН раз
    - использовангие памяти: УМЕРЕННОЕ т.к. требуется ДОПОЛНИТЕЛЬНАЯ память для хранения результатов в СЛОВАРЕ или МАССИВЕ
    => сочетает преимущества рекурсии + итерации, результат: скорость при умеренном использовании памяти. Удачно! сохрани РЕКУРСИВНОЙ структуры, НО избегай ИЗБЫТОЧНЫХ выражений. */

/* ЗАДАЧА 'для разминки': напиши функцию, которая принимает строку и возвращает количество гласных букв (a, e, o, u, i) в этой строке. УЧТИ: регистр НЕ важен */

// пример ФУНКЦИОНАОТНОГО подхода - метод 'filter'

func countVowels(in input: String) -> Int {
    let vowels = "aeiouAEIOU"
    return input.filter {vowels.contains ($0) }.count
}
// пример использования
let vowelCount = countVowels(in: "Hello, Dolly!")
print("Количество гласных - \(vowelCount)")
/*
 COMMENTS:
 1. входной ИМЕНОВАННЫЙ параметр = input
 2. используй метод 'filter' для выбора только ГЛАСНЫХ и верни их количество
 3. определи СТРОКУ 'vowels', она содержит ВСе гласные буквы
 4. фильтрация: метод 'filter' применяется к строке 'vowels'  -> он создает НОВУЮ коллекцию (НЕ МЕНЯЯ входной параметр) согласно условию - если символ содержится в строке 'vowels'
 ЗАКЛЮЧЕНИЕ: этот способ ЛАКОНИЧЕН + ФУНКЦионален => код ЧИТАЕМ + УДОБЕН для понимания. */

// вариант 2 - проще и понятней
func countOfVowels(in input: String) -> Int { // функция принимает входной ИМЕНОВАННЫЙ параметр  -  input с англ. "вход" напр. устройство ввода - 'input device of comp'
    let vowels = "aeiouAEIOU" // хранит строку как последовательность символов (м.б. цифры, пробелы, спец.символы - воспринимаются как ЕДИНОЕ целое)
    
    var count = 0 // переменная для хранения гласных
    
    for character in input { // проходим по КАЖДОМУ элементу в строке
        if vowels.contains(character) { // проверяем: является ли ТЕКУЩИЙ элемент гласной?
            count += 1 // если да, увеличиваем счетчик
        }
    }
    return count // возвращаем ОБЩЕЕ количество гласных
}
// пример исполльзования функции
let exempleString = "In the Hole lived a Hobbit."
let vowelsCount = countOfVowels(in: exempleString)
print("Количество гласных: \(vowelCount)")

/* Задача 1: Функция для вычисления периметра прямоугольника
 Создайте функцию `perimeterOfRectangle`, она принимает длину и ширину прямоугольника и возвращает его периметр */ 


/* Задача 2: Функция для проверки четности числа
 Создайте функцию `isEven`, которая принимает целое число и возвращает `true`, если число четное, и `false` в противном случае.
 Задача 3: Функция для конкатенации строк
 Создайте функцию `concatStrings`, которая принимает две строки и возвращает их объединение с пробелом между ними.
 Задача 4: Функция для вычисления факториала числа
 Создайте рекурсивную функцию `factorial`, которая принимает целое число и возвращает его факториал. Факториал числа  (обозначается как  ) — это произведение всех положительных целых чисел от 1 до */

